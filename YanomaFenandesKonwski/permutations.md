Esse problema eu fiz usando recusividade, pois é clássico exemplo do qual pode ser utilizado essa estrutura. Então na parte de código, fiz um função auxiliar, da qual vou chamar recursivamente. E chamei ela no primeiramente dentro de permute. Aí no caso partindo para linha de raciocínio, o que eu fiz, imagina que primeiro queremos pegar qual vai ser os primeiros números das combinações, então coloquei "for i in range(len(restantes)):" que vai pegar o 1, o 2 e o 3 como primeiros números que coloquei como novo caminha. Após isso vão sobrar como novos_restantes para o numero 1, [2,3], para o 2, [3,1] e para o 3, [1,2]. Aí que entra a recurção, que aí vou fazer namente, para o [2,3] temos ou [3] como  novos restantes ou o [2], até ficar [] como novos restantes que aí sim é adicionado esses números a lista, que nesse caso que dei o exemplo, pode ser [1,2,3] ou [1,3,2]. Para exemplificar e o que me ajuda entender isso, é de que a recursividade funciona como uma arvora, no loop for ela gera todas possibilidade e chama para cada possibilidade novas funções com o que sobrou, que vai fazendo isso, até que não seja possível mais, que é quando não existe restantes, e assim pega todas as ramificações como coloquei no meu código e adiciona no resultado o caminho, que foi se acumulando por exemplo, no primeiro foi [1], aí para esse [1], poderia ser depois duas possibilidades de caminho [1,2] ou [1,3] sobrando dois possiveis novos restantes [3] ou [2] que aí entrariam no novo_caminho anterior e por final sobreria novos restantes [], assim os dois caminhos são adicionados dentro do resultado que é uma lista vazia de inicio.